---
layout:	single
title: "[Java] 029. Comparator"
excerpt: "Comparator에 대해 알아보자"
categories: Java
tag: [STUDY, Java]
toc: true
toc_sticky: true
author_profile: false
sidebar:
    nav: "docs"
search: true
permalink: categories/java/029-Comparator
# last_modified_at:

---

# Comparator

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class Comparator {
	
	/*
		# Compare
		 - 비교하다
		
		# Comparable
		 - 비교 가능하다
		 
		 - 이 인터페이스를 구현한 클래스는 서로 크기 비교가 가능한 클래스가 된다.
		 인터페이스가 Swimmer라고 하면 수영 가능한 느낌이었죠
		 컴퍼러블 인터페이스에 달아놓으면 서로 크기 비교 가능한 클래스가 된다는 겁니다.
		 
		 
		# Comparator
		 - 비교하는 것
		 
		 - 이 인터페이스를 구현한 클래스는 비교의 기준으로 사용할 수 있다.
	 */
	
	public static void main(String[] args) {

		Grape g1 = new Grape(0, 30, 5, 0);
		Grape g2 = new Grape(1, 20, 10, 1);
		Grape g3 = new Grape(1, 10, 30, 0);
		Grape g4 = new Grape(0, 40, 20, 2);
		Grape g5 = new Grape(1, 30, 15, 1);
		Grape g6 = new Grape(1, 20, 15, 0);
		Grape g7 = new Grape(0, 15, 40, 1);
		Grape g8 = new Grape(1, 40, 30, 2);
		
		// compareTo의 return타입은 int
		System.out.println(g1.compareTo(g2));
		
		ArrayList<Apple> apples = new ArrayList<>();
		apples.add(new Apple());
		apples.add(new Apple());
		apples.add(new Apple());

		// Collections.sort(apples); // Comparable이 구현되어 있지 않아서 불가능
		
		ArrayList<Integer> apples2 = new ArrayList<>();
		apples2.add(13);
		apples2.add(0);
		apples2.add(-55);
		
		// 이걸 만들어 놓으면 좋은 점
		ArrayList<Grape> grapes = new ArrayList<>();
		
		grapes.add(g1);
		grapes.add(g2);
		grapes.add(g3);
		grapes.add(g4);
		grapes.add(g5);
		grapes.add(g6);
		grapes.add(g7);
		grapes.add(g8);
		
		// sysout은 사실 해당 인스턴스의 toString()을 호출하여 콘솔에 출력하는 메서드이다.
		System.out.println(grapes);
		
		// Collections.sort는 크기 비교를 해당 클래스의 compareTo 메서드를 가지고 비교해서 정렬한다.
		Collections.sort(grapes);
		System.out.println(grapes);

		// Collections.reverse는 크기 비교를 해당 클래스의 compareTo 메서드를 가지고 비교해서 정렬한다.
		Collections.reverse(grapes);
		System.out.println(grapes);
		
		Collections.sort(grapes, new 포도분류기_크기());
		System.out.println(grapes);
		
		Collections.sort(grapes, new GrapeComparatorQtyDesc());
		System.out.println(grapes);
		
	}
}

// 비교 가능한 컬렉션을 붙이면 사용 가능 Collections.sort 등..
class Grape implements Comparable {
	static String[] ORIGIN_NAMES = { "칠레", "스페인", "프랑스" };
	static String[] COLOR_NAMES = { "적", "청" };
	
	final public static int RED = 0;
	final public static int GREEN = 1;

	int color;
	int size;
	int qty; // 열매 개수
	int origin; // 원산지

	public Grape(int color, int size, int qty, int origin) {
		this.color = color;
		this.size = size;
		this.qty = qty;
		this.origin = origin;
	}
	
	@Override
	public String toString() {
		// 이 클래스를 문자열로 변환한다면 어떤 모양일지 정의하는 메서드
		// toString()의 기본 동작은 현재 인스턴스의 클래스 이름과 주소값을 문자열로 반환하는 것이다.
		return String.format("{%s/%d/%d/%s}", COLOR_NAMES[color], size, qty, ORIGIN_NAMES[origin]);
	}
	
	@Override
	public int compareTo(Object o) { // Object o에 비교할 인스턴스가 들어온다고 가정
		/*
		 	# 비교 메서드의 규칙
		 	
		 	 - 현재 인스턴스가 매개변수로 전달된 인스턴스보다 작으면 -1을 리턴해야 한다. (또는 음수)
		 	 - 현재 인스턴스가 매개변수로 전달된 인스턴스보다 크면 1을 리턴해야 한다. (또는 양수)
		 	 - 두 인스턴스가 서로 같은 값이라면 0을 리턴해야 한다.
		 	 - 각 기본 타입의 compare 메서드를 통해 쉽게 크기 비교를 할 수 있다.
		 */
//		if (this.qty < ((Grape) o).qty) {
//			return -1;
//		} else if (this.qty > ((Grape) o).qty) {
//			return 1;
//		} else {
//			return 0;
//		}
		
		// int의 Comparable 호출, 위의 코드와 같음
		return Integer.compare(this.qty, ((Grape) o).qty);
	}

}
// 기본 오름차순 (포도 크기를 기준으로 정렬)
class 포도분류기_크기 implements Comparator<Grape> {
	@Override
	public int compare(Grape o1, Grape o2) {
		// 크기가 같을 때는 색상 순서로 나오게 하기
		int compare1 = Integer.compare(o1.size, o2.size);

		if (compare1 == 0) {
			// 비교 메서드의 규칙 참고
			return Integer.compare(o1.color, o2.color); // 적 먼저
			// return Integer.compare(o1.color, o2.color) * -1; // 뒤집고 싶으면 * -1, 청 먼저
		} else {
			return compare1;
		}
	}
}

/*
	포도알 개수 기준 내림차순 정렬을 하되, 포도알 개수가 같다면 원산지 이름 기준으로 오름차순 정렬해보기
	(잘 확인할 수 있도록 데이터 3개 더 추가해보기)
*/
class GrapeComparatorQtyDesc implements Comparator<Grape> {

	@Override
	public int compare(Grape o1, Grape o2) {
		int compare1 = Integer.compare(o1.qty, o2.qty) * -1;

		if (compare1 == 0) {
			// 문자열 순서대로 정렬
			return o1.ORIGIN_NAMES[o1.origin].compareTo(o2.ORIGIN_NAMES[o2.origin]);

		} else {
			return compare1;
		}

	}
	
}

```

