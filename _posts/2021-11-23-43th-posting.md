---
layout:	single
title: "[Java] 015. 객체 지향 프로그래밍 (Object Oriented Programming)"
excerpt: "객체 지향 프로그래밍 (Object Oriented Programming)에 대해 알아보자"
categories: Java
tag: [STUDY, Java]
toc: true
toc_sticky: true
author_profile: false
sidebar:
    nav: "docs"
search: true
permalink: categories/java/015-OOP
# last_modified_at:
---

# 객체 지향 프로그래밍 (Object Oriented Programming)

**객체 지향 프로그래밍이란** 소프트웨어를 개발할 때 부품에 해당하는 객체를 먼저 만들고, 이것들을 하나씩 조립해서 완성된 프로그램을 만드는 기법을 말한다. 

세상에 존재하는 모든 것(객체)들을 변수화 함수로 표현하려는 프로그래밍 방법론이다.  
현실에 존재하는 객체 단위로 묶어 표현하여 개발을 효율적으로 진행할 수 있다.

### 객체란?

객체(Object)란 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른 것과 식별 가능한 것을 말한다.  
ex) 물리적으로 존재 : 자동차, 자전거, 책, 사람  
ex) 추상적인 것 : 학과, 강의, 주문

객체는 속성과 동작으로 구성되어 있다.  
ex) 동작 : 웃다, 먹다, 달린다, 멈춘다.  
ex) 속성 : 이름, 나이, 색깔, 속도, 모델명 

**자바는 속성을 필드(field), 동작을 메서드(method)라고 부른다.**

## 객체 지향 프로그래밍의 특징
### 캡슐화(Encapsulation)

캡슐화란 객체의 필드, 메서드를 하나로 묶고, 실제 구현 내용을 감추는 것이다.  
외부 객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메서드만 이용할 수 있다.

필드와 메서드를 캡슐화하여 보호하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하기 위함이다.  
자바 언어는 캡슐화된 멤버를 노출시킬 것인지, 숨길 것인지를 결정하기 위해 접근 제한자(Access Modifier)를 사용한다. 접근 제한자는 객체의 필드와 메서드의 사용 범위를 제한함으로써 외부로부터 보호한다.

### 상속(Inheritance)

객체 지향 프로그래밍에서도 부모 역할의 상위 객체와 자식 역할의 하위 객체가 있다.  
상위 객체는 자기가 가지고 있는 필드와 메서드를 하위 객체에게 물려주어 하위 객체가 사용할 수 있도록 해준다.

상속은 상위 객체를 재사용해서 하위 객체를 쉽고 빨리 설계할 수 있도록 도와주고, 반복된 코드의 중복을 줄여준다.  
상속은 상위 개체의 수정으로 모든 하위 객체들의 수정 효과를 가져오므로 유지 보수 시간을 최소화시켜주기도 한다.

### 다형성(Polymorphism)

다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다.  
자바는 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용한다. 다형성의 효과로 객체는 부품화가 가능하다. 예를 들어 자동차를 설계할 때 타이어 인터페이스 타입을 적용했다면 이 인터페이스를 구현한 실제 타이어들은 어떤 것(한국 타이어, 금호 타이어 등)이든 상관없이 대입이 가능하다.

## 객체와 클래스

메모리에서 사용하고 싶은 객체가 있다면 우선 설계도로 해당 객체를 만드는 작업이 필요하다. 자바에서는 이 <u>설계도</u>가 바로 **클래스(class)**이다. <u>클래스에는 객체를 생성하기 위한 필드와 메서드가 정의되어 있다.</u>  
<u>클래스로부터 만들어진 객체</u>를 해당 클래스의 **인스턴스(instance)**라고 한다. 자동차 객체는 자동차 클래스의 인스턴스인 셈이다. 그리고 <u>클래스로부터 객체를 만드는 과정</u>을 **인스턴스화**라고 한다. 하나의 클래스로부터 여러 개의 인스턴스를 만들 수 있는데, 이것은 동일한 설계도로부터 여러 대의 자동차를 만드는 것과 동일하다.

### 클래스(class)

클래스를 정의한 시점에서는 실체가 없다.  
클래스를 이용해 실제 객체를 생성할 때는 new를 사용한다.  
모든 클래스는 참조형 변수 타입이다.

main은 반드시 public class안에 존재해야 하고,  
public class의 이름은 반드시 파일명과 같아야 한다.  
즉, 한 파일에는 하나의 public class만 존재할 수 있다.

## 객체 생성과 클래스 변수

클래스를 선언한 다음, 컴파일 했다면 객체를 생성할 설계도가 만들어진 셈이다.  
클래스로부터 <u>객체를 생성하는 방법</u>은 **new연산자**를 생성하면 된다.

new는 클래스로부터 객체를 생성시키는 연산자이다.  
new연산자 뒤에는 생성자가 오는데, 생성자는 클래스() 형태를 가지고 있다.  
new연산자로 생성된 객체는 메모리 힙(heap)영역에 생성된다.  
메모리 내에서 생성된 객체의 위치를 모르면 객체를 사용할 수 없다.  
그래서 new연산자는 힙 영역에 객체를 생성시킨 후, 객체의 주소를 리턴하도록 되어 있다.   
이 주소를 참조 타입 클래스 변수에 저장해 두면, 변수를 통해 객체를 사용할 수 있다.

## 클래스의 구성 멤버

클래스에는 객체가 가져야 할 구성 멤버가 선언된다. 구성 멤버에는 필드(Field), 생성자(Constructor), 메서드(Method)가 있다. 이 구성 멤버들은 생략되거나 복수 개가 작성될 수 있다.

### 필드

필드는 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳이다. 변수는 생성자와 메서드 내에서만 사용되고 생성자와 메서드가 실행 종료되면 자동 소멸된다. 하지만 <u>필드는 생성자와 메서드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재</u>한다.

```java
class Banana {
    // 필드 (인스턴스 변수)
	int qty;
	String brand;
}
```



### 생성자

생성자는 new 연산자로 호출되는 특별한 중괄호{} 블록이다. 역할은 **객체 생성 시 초기화를 담당**한다. 필드를 초기화하거나, 메서드를 호출해서 객체를 사용할 준비를 한다. <u>클래스 이름으로 되어 있고 리턴 타입이 없다</u>.

#### 기본 생성자

모든 클래스는 생성자가 반드시 존재하며, 하나 이상을 가질 수 있다.  
클래스 내부에 생성자 선언을 생략했다면 컴파일러는 중괄호{} 블록 내용이 비어있는 기본 생성자(Default Constructor)를 바이트 코드에 자동 추가시킨다. 그렇기 때문에 클래스에 생성자를 선언하지 않아도 new 연산자 뒤에 기본 생성자를 호출해서 객체를 생성할 수 있다.

그러나 클래스에 명시적으로 선언한 생성자가 한 개라도 있으면, 컴파일러는 기본 생성자를 추가하지 않기 때문에 따로 적어줘야 한다.  
명시적으로 생성자를 선언하는 이유는 객체를 다양하게 초기화하기 위해서이다.

```java
public class Constructor {

	public static void main(String[] args) {
		new Peach(true);
		new Peach(false);
	}
}

class Peach {
	boolean white; // true 백도 false 황도

	// 기본 생성자 (매개변수에 아무 것도 없는 생성자)
	public Peach() {
		this.white = true;
	}

	// 기본 생성자가 아닌 생성자가 존재한다면, 기본 생성자를 자동으로 생성하지 않는다.
	Peach(boolean white) {
		this.white = white;
	}
```

### this.필드

필드와 매개 변수 이름이 동일 하면 생성자 내부에서 해당 필드에 접근할 수 없다.  
왜냐하면 동일한 이름의 매개 변수가 사용 우선순위가 높기 때문이다.  
해결 방법은 필드 앞에 "this."을 붙이면 된다.  
this는 객체 자신의 참조인데, 우리가 우리 자신을 "나"라고 하듯이 객체가 객체 자신을 this라고 한다.  
"this.필드"는 this라는 참조 변수로 필드를 사용하는 것과 동일하다.

```java
Banana(int qty, String brand) {
		// this : 현재 인스턴스를 정확하게 가리키는 키워드
		this.qty = qty;
		this.brand = brand;
	}
```

### 생성자 오버로딩(Overloading)

자바는 다양한 방법으로 객체를 생성할 수 있도록 생성자 오버로딩(Overloading)을 제공한다.  
생성자 오버로딩이란 매개 변수를 달리하는 생성자를 여러 개 선언하는 것을 말한다. 

```java
class Banana {
	int qty;
	String brand;

	// 기본 생성자 (매개변수에 아무것도 없는 생성자)
	public Banana() {
		System.out.println("바나나가 생성되었습니다.");
	}

	// 생성자 오버로딩
	Banana(int qty, String brand) {
		// this : 현재 인스턴스를 정확하게 가리키는 키워드
		this.qty = qty;
		this.brand = brand;
	}

	void info() {
		System.out.println("= = 바나나 정보 = =");
		System.out.printf("개수: %d\n브랜드명: %s\n", this.qty, this.brand);
	}
}
```

생성자 오버로딩 시 주의할 점은 매개 변수의 타입과 개수 그리고 선언된 순서가 똑같을 경우 매개 변수 이름만 바꾸는 것은 생성자 오버로딩이라고 볼 수 없다.

```java
// 오버로딩 아님
Car(String model, String color) {...}
Car(String color, String model) {...}
```



### 메서드

메서드는 객체의 동작에 해당하는 중괄호{} 블록이다. 중괄호 블록은 이름을 가지고 있는데 이것이 메소드 이름이다. 메서드는 필드를 일고 수정하는 역할도 하지만, 다른 객체를 생성해서 다양한 기능을 수행하기도 한다. 메서드는 객체 간의 데이터 전달의 수단으로 사용된다. 외부로부터 매개값을 받을 수도 있고, 실행 후 어떤 값을 리턴할 수도 있다.

#### 메서드 선언

메서드 선언은 선언부 (리턴타입, 메서드이름, 매개변수선언)와 실행 블록으로 구성된다.  
메서드 선언부를 메서드 시그니처(signature)라고 한다.

```
리턴타입 : 메서드가 리턴하는 결과 타입 표시
매개변수선언 : 메서드가 실행할 때 필요한 데이터를 받기 위한 변수

리턴타입 메서드이름 ([매개변수선언, ...]) {
	// 메서드 실행 블록
	실행할 코드를 작성하는 곳
}
```

##### 리턴 타입

리턴 타입은 메서드가 실행 후 리턴하는 값의 타입을 말한다.  
메서드는 리턴값이 있을 수도 있고 없을 수도 있다.  
메서드가 실행 후 결과를 호출한 곳에 넘겨줄 경우에는 리턴값이 있어야 한다.

##### 매개 변수 선언

```
double divide(int x, int y) {...}
```

이렇게 선언된 divide() 메서드를 호출할 때는 반드시 두 개의 int 값을 주어야 한다.

```
double result = divide(10, 20);
```

### 인스턴스 멤버와 this

인스턴스(instance)멤버란 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메서드를 말하는데, 이들을 각각 인스턴스 필드, 인스턴스 메서드라고 부른다.  
인스턴스 필드와 메서드는 객체에 소속된 멤버이기 때문에 객체없이는 사용할 수 없다.

```java
class Apple {
	/*
	 * # 인스턴스 변수
	 * 
	 * 	- 클래스 내부에 선언한 변수
	 * 	- 각 인스턴스마다 값이 다를 수 있는 변수
	 * 	- aka. 필드, 속성, 멤버 변수, 멤버, 상태, ...
	 */
	int size;
	int calorie;
	int sweet;
	int price;
	char grade;
	
	/*
	 * # 인스턴스 메서드
	 * 
	 * 	- 해당 인스턴스의 변수를 변화시키는 메서드
	 */
	void eat() {
		size--;
		calorie -= 10;
	}
}
```

